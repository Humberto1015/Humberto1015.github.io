[{"categories":["Computer Science"],"contents":"假設我們正在開發後端的某些功能，需要一個Object來提供給客戶的服務：像是新增用戶、取得用戶資料、取得所有用戶等等，我們可以把這些功能都包在一個叫CustomerService的Class裡。\n0 1 2 3 4 5 6 7 8  public class CustomerService { private static final LinkedList\u0026lt;Customer\u0026gt; customers = new LinkedList\u0026lt;\u0026gt;(); public CustomerService() {} // add methods here  // 1. add customer  // 2. get customer by email  // 3. get all customers }   這樣的寫法有一個缺點，那就是每個調用它的人都需要new一個新的CustomerService Object出來，但事實上，我們只需要一個Global的CustomerService Object來提供服務就足夠了。\n這個時候就可以運用Singleton Design Pattern，將此Class寫成以下這個樣子：\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public final class CustomerService { private static final LinkedList\u0026lt;Customer\u0026gt; customers = new LinkedList\u0026lt;\u0026gt;(); private static CustomerService INSTANCE; private CustomerService() {} public static CustomerService getInstance() { if (INSTANCE == null) { INSTANCE = new CustomerService(); } return INSTANCE; } // add methods here  // 1. add customer  // 2. get customer by email  // 3. get all customers }   從上面的寫法可知，我們其實可以只在第一次被呼叫的時候再建立Object，如果Object已被建立過，只需要直接return即可，在單執行緒的情況下，這可以確保我們每次操作這個CustomerService都是用同一個實體。\n以下用一個簡易的旅館訂房系統來說明如何調用這個Global的CustomerService，我們可以直接呼叫getInstance Method來取得該Object。\n0 1 2 3 4  public class HotelResource { private static final CustomerService customerService = CustomerService.getInstance(); // Impelemets other methods here }   但如果是在多執行緒的情況下，仍然可能發生CustomerService被new多於一次的情況，所以可再將該Class稍作改寫：\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public final class CustomerService { private static final LinkedList\u0026lt;Customer\u0026gt; customers = new LinkedList\u0026lt;\u0026gt;(); private static CustomerService INSTANCE; private CustomerService() {} public static CustomerService getInstance() { if (INSTANCE == null) { synchronized(CutomerService.class){ if(instance == null){ instance = new CustomerService(); } } } return INSTANCE; } // add methods here  // 1. add customer  // 2. get customer by email  // 3. get all customers }   如此一來，就可以確保在多執行緒的情況下，始終最多只有一個CustomerService實體（如果該Service沒有被調用，則不會建立實體）\n","permalink":"https://Humberto1015.github.io/blog/post-5/","tags":["Java","Design Pattern"],"title":"淺談Singleton Pattern"},{"categories":["Computer Science"],"contents":"目標 既然是第一個APP，那就用Dcard API來撈一些資料，並使用SwiftUI來呈現這些資料吧！\nView 的部分 View的部分，我使用了List來呈現利用Dcard API撈到的文章標題。 NetworkManager 是我用來處理API抓取資料的事情，後面會提到。\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  struct ContentView: View { @ObservedObject var networkManager = NetworkManager() var body: some View { NavigationView { List(networkManager.posts) { post in VStack(alignment: .leading) { Text(post.title) } }.navigationBarTitle(\u0026#34;Posts\u0026#34;) }.onAppear { networkManager.fetchPost() } } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } }   Data 的部分 此處是定義文章的資料結構，加上 Decodable protocol 是因為要使用JSONDecoder，將抓取到的資料Decode成我們希望的形式，而 Identifiable protocol 則是會賦予這個結構一個 id 屬性，方便搭配 ForEach 或 List。\n0 1 2 3  struct Post: Decodable, Identifiable { let id: Int let title: String }   Networking： 使用Dcard API抓取資料 這裡要注意 @Published 與前面所提到的 @ObservedObject。\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class NetworkManager: ObservableObject { let dcardURL = \u0026#34;https://www.dcard.tw/service/api/v2/posts\u0026#34; @Published var posts = [Post]() func fetchPost() { performRequest(urlString: dcardURL) } func performRequest(urlString: String) { if let url = URL(string: urlString) { let session = URLSession(configuration: .default) let task = session.dataTask(with: url) { (data, response, error) in if error == nil { let decoder = JSONDecoder() if let data = data { do { let results = try decoder.decode([Post].self, from: data) self.posts = results } catch { print (error) } } } } task.resume() } } }   ","permalink":"https://Humberto1015.github.io/blog/post-4/","tags":["Networking","swift"],"title":"SwiftUI初體驗！ List + Dcard API"},{"categories":["Computer Science"],"contents":"題目簡介 要你設計一個Handler，必須包含兩個方法： insert 與 getMedian 。 insert 方法可以用來新增integer到我們的資料結構內，而題目要求 getMedian 方法必須在O(1)的時間複雜度內回傳資料結構中的中位數。\n想法 我們首先從資料結構開始思考，如果利用一個array來存資料，為了確保能夠在O(1)的時間複雜度內回傳array中的中位數，則每次insert的時候都需要做排序，這題沒辦法使用counting sort，因為我們並不知道data的範圍，所以如果要做排序的話，我們假設排序所需的時間複雜度為O(nlogn)。\n那有沒有更快的方式呢？仔細去思考的話可以發現，要求算中位數，我們並不需要讓整個array是排序好的狀態，可以試著將資料分成兩半，分別是比較小的一半A，以及比較大的一半B，並確保兩這兩半資料的個數相差不超過1，接著我們需要能夠取得A裡面的最大元素以及B裡面的最小元素，如此一來就可以求算中位數了。為了達到這個目的，我們需要Maintain兩個heaps，分別是Max Heap與Min Heap，Max Heap內存的是最小的元素們，Min Heap內存的是最大的元素們，每次insert完，需要對整個結構做一次balance，並更新median的值，之後便可以用O(1)的時間複雜度存取。\n複雜度  insert : O(logn) getMedian : O(1)  實作 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  #include \u0026lt;queue\u0026gt; using namespace std; class MedianHandler { private: double median; // Max Heap \tpriority_queue\u0026lt;int\u0026gt; maxHeap; // Min Heap \tpriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minHeap; public: MedianHandler() { } void insert(int number) { // 1. push \tif (maxHeap.empty()) maxHeap.push(number); else number \u0026gt; maxHeap.top() ? minHeap.push(number) : maxHeap.push(number); // 2. check balance \tif (minHeap.size() - maxHeap.size() == 2) { maxHeap.push(minHeap.top()); minHeap.pop(); } if (maxHeap.size() - minHeap.size() == 2) { minHeap.push(maxHeap.top()); maxHeap.pop(); } // 3. update median \tif (minHeap.size() == maxHeap.size()) { median = (double)(minHeap.top() + maxHeap.top()) / 2; } else { median = minHeap.size() \u0026gt; maxHeap.size() ? minHeap.top() : maxHeap.top(); } } double getMedian() { return median; } };   ","permalink":"https://Humberto1015.github.io/blog/post-3/","tags":["Algorithms","Data Structures"],"title":"Median Handler"},{"categories":["Computer Science"],"contents":"我對於Heap的認知是：是一棵加上constraints的binary tree，以Min-Heap為例，要求每一個node的值要比其child node的值小。由於是complete binary tree，所以給定一個node的index，可輕易算出child nodes的index，適合用Array來保存。\nBasic Operations  push()：新增一個元素到Min Heap，需要做heapify來將整棵binary tree重新調整成Min Heap，時間複雜度為O(logn)。 pop()：彈出Min Heap中的最小元素，需要做heapify來將整棵binary tree重新調整成Min Heap，時間複雜度為O(logn)。 peak()：回傳Min Heap中最小的元素，時間複雜度為O(1)。 heapify()：將整棵binary tree重新調整成Min Heap，時間複雜度為O(logn)。  Implementation 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; class MinHeap { public: // constructor \tMinHeap(int size) { capacity = size; lastIndex = -1; heap.resize(capacity); } void push(int val) { heap[++lastIndex] = val; heapify(lastIndex); } void pop() { // step 1. swap the first and the last element \tswap(0, lastIndex--); // step 2. perform heapify \theapify(lastIndex); } int peak() { return heap[0]; } // debug function for heapify operation \tvoid printArray() { for (int i = 0; i \u0026lt;= lastIndex; ++i) cout \u0026lt;\u0026lt; heap[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } private: int left(int i) { return 2 * i + 1; } int right(int i) { return 2 * i + 2; } int parent(int i) { return (i - 1) / 2; } void swap(int i, int j) { int temp = heap[i]; heap[i] = heap[j]; heap[j] = temp; } void heapify(int i) { int smallest = i; int l = left(i); int r = right(i); if (l \u0026lt;= lastIndex \u0026amp;\u0026amp; heap[l] \u0026lt; heap[smallest]) smallest = l; if (r \u0026lt;= lastIndex \u0026amp;\u0026amp; heap[r] \u0026lt; heap[smallest]) smallest = r; if (smallest != i) { swap(smallest, i); } if (i == 0) return; heapify(parent(i)); } vector\u0026lt;int\u0026gt; heap; int lastIndex; int capacity; }; int main() { MinHeap heap(100); heap.push(5); heap.push(3); heap.push(6); heap.push(7); heap.printArray(); heap.pop(); heap.printArray(); return 0; }   ","permalink":"https://Humberto1015.github.io/blog/post-1/","tags":["Heap"],"title":"Min Heap Construction"},{"categories":["Life"],"contents":"其實在很久以前，我就很想學西洋棋，一則是因為棋盤與棋子所散發的工藝美感，二則是因為取勝的棋路千變萬化，所以我認為下棋是一個探索智慧的過程。前一陣子，為了訓練我的英文聽力，我開始養成睡前看美劇的習慣，在我陸續看完了《六人行》與《愛蜜莉在巴黎》之後，我發現有一部迷你影集始終出現在Netflix的Top 10榜單，即本篇要討論的影集──《后翼棄兵》。\nBeth Harmon，從小因為母親發生嚴重車禍身亡而成為孤兒，她被孤兒院教會收留之後，在某次因緣巧合下，碰見了在地下室獨自下著西洋棋的工友Mr. Shaibel，他發現這個不苟言笑的小女孩居然透過幾次觀察便學會了各個棋種的移動方式，因此決定教她西洋棋，開啟了她的下棋生涯。Beth在一步一步成為棋后的過程中，遇到了不少貴人，除了多位曾經幫助她過關斬將的男性棋士之外，她內心深處最感謝的，當然就是她的啟蒙恩師Mr. Shaibel。\n在我大學一年級的時候，當時我們有一門必修課是程式設計，需要寫一些程式作業，對於我這個從來沒有coding經驗的菜鳥來說，除了第一個簡單的作業之外，我都覺得有點吃力。當時在回宿舍寫程式作業的路上，偶然遇見一個同班的大學同學，他是班上大家公認的程式大神，我就和他小小抱怨了一下我覺得作業有點沒頭緒的事情，那時他就說：「反正我房間跟你同一層樓，我去幫你看看你的程式碼哪裡出錯吧！」就這樣，我從他身上學到了一些程式除錯的技巧，還有不懂就去問Google的精神，這件小事對他來說也許只是舉手之勞，但對於我以後的資工人生活有很大的幫助。\n大學三年級準備研究所考試的時候，當時與一位曾經一起參加系上活動的同學一起決定當彼此的戰友，為考上理想的學校一起奮鬥，在五個月的時光裡，我們一起讀書、運動，最終也順利考上自己喜歡的學校，時至今日，我們還是會一起分享自己人生中的經驗給對方。\n兩年前，我還是個碩士生的時候，我每週都會去校內的健身房做重量訓練，那時候的我對於健力三項並不熟悉，某次在做槓鈴臥推的時候，我因為力竭而推不起那沈重的槓鈴，就在這個時候，有一個黑人同學及時幫助我拉起槓鈴使我免於受傷，更在之後告訴我一些重量訓練的技巧，實是受益良多。 在我們人生中，或多或少都遇過一些貴人，可能是一段愛情、一段友情，甚至是一個萍水相逢的陌生人，不管他們幫助我們是基於利益交換，或是不求回報、純粹的幫助，都使我們在人生中的棋局中，有了更好的進展，透過這篇文章，我想謝謝那些曾經出現在我生命中的貴人！\n","permalink":"https://Humberto1015.github.io/blog/post-2/","tags":["Netflix"],"title":"《后翼棄兵》觀後感"}]